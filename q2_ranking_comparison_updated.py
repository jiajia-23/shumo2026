"""\n问题2：评分方法对比与排名分析\n=================================\n\n任务目标：\n1. 计算所有参赛选手的三种排名：\n   - 原排名（actual placement）\n   - 导师评分排名（judge-based ranking）\n   - 另一评分方法排名（alternative scoring method）\n\n2. 模拟比赛过程：\n   - 基于比赛信息表格和预测的投票数\n   - 按照另一评分法完整模拟比赛\n   - 得出最终排名\n\n3. 相关性分析：\n   - 计算同季三个排名向量的两两斯皮尔曼系数\n   - 评估哪种合并方法更偏向于观众\n\n输出：\n- 排名总表：选手名 | 季数 | 原排名 | 导师评分排名 | 另一评分方法排名\n- 斯皮尔曼系数表格\n"""\n\nimport pandas as pd\nimport numpy as np\nfrom scipy.stats import spearmanr, rankdata\nimport warnings\nimport os\nimport matplotlib.pyplot as plt\nimport seaborn as sns\n\nwarnings.filterwarnings('ignore')\n\nprint("=" * 60)\nprint("问题2：评分方法对比与排名分析")\nprint("=" * 60)\n\n\nclass RankingComparisonAnalyzer:\n    """排名对比分析器"""\n\n    def __init__(self, original_data_path, competition_info_path, fan_estimation_path):\n        """\n        初始化分析器\n\n        Args:\n            original_data_path: 原始数据文件路径\n            competition_info_path: 比赛信息表格路径\n            fan_estimation_path: 粉丝投票预测结果路径\n        """\n        self.original_data_path = original_data_path\n        self.competition_info_path = competition_info_path\n        self.fan_estimation_path = fan_estimation_path\n\n        self.original_df = None\n        self.competition_info = None\n        self.fan_estimation = None\n        self.processed_data = None\n        self.ranking_table = None\n        self.correlation_table = None\n\n    def load_data(self):\n        """加载所有必要的数据"""\n        print("\n[Step 1] 加载数据...")\n\n        # 加载原始数据\n        self.original_df = pd.read_csv(self.original_data_path, encoding='utf-8-sig')\n        print(f"  原始数据: {len(self.original_df)} 条记录")\n\n        # 加载比赛信息表格\n        self.competition_info = pd.read_csv(self.competition_info_path, encoding='utf-8-sig')\n        print(f"  比赛信息: {len(self.competition_info)} 条记录")\n\n        # 加载粉丝投票预测结果\n        self.fan_estimation = pd.read_csv(self.fan_estimation_path, encoding='utf-8-sig')\n        print(f"  粉丝投票预测: {len(self.fan_estimation)} 条记录")\n\n        return self\n\n    def preprocess_data(self):\n        """预处理数据，提取每周的评委分和选手信息"""\n        print("\n[Step 2] 数据预处理...")\n\n        weekly_data = []\n\n        # 遍历每个选手\n        for idx, row in self.original_df.iterrows():\n            celebrity = row['celebrity_name']\n            season = row['season']\n            results = row['results']\n\n            # 获取原始排名（placement）\n            placement = None\n            if 'placement' in self.original_df.columns and pd.notna(row['placement']):\n                try:\n                    placement = float(row['placement'])\n                except:\n                    placement = None\n\n            # 解析results获取最终排名\n            final_rank = None\n            exit_week = None\n\n            if isinstance(results, str):\n                if 'Eliminated Week' in results:\n                    exit_week = int(results.split('Week ')[-1])\n                elif '1st Place' in results:\n                    final_rank = 1\n                elif '2nd Place' in results:\n                    final_rank = 2\n                elif '3rd Place' in results:\n                    final_rank = 3\n                elif '4th Place' in results:\n                    final_rank = 4\n                elif results == 'Withdrew':\n                    # 退赛选手需要找到退出周次\n                    for week in range(1, 12):\n                        judge_scores = []\n                        for judge_num in range(1, 5):\n                            col_name = f'week{week}_judge{judge_num}_score'\n                            if col_name in self.original_df.columns:\n                                score = row[col_name]\n                                if pd.notna(score) and score != 0:\n                                    judge_scores.append(float(score))\n                        if len(judge_scores) == 0 and week > 1:\n                            exit_week = week - 1\n                            break\n\n            # 遍历每一周，提取评委分\n            for week in range(1, 12):\n                judge_scores = []\n                for judge_num in range(1, 5):\n                    col_name = f'week{week}_judge{judge_num}_score'\n                    if col_name in self.original_df.columns:\n                        score = row[col_name]\n                        if pd.notna(score) and score != 0:\n                            judge_scores.append(float(score))\n\n                if len(judge_scores) > 0:\n                    avg_judge_score = np.mean(judge_scores)\n                    is_exited = (exit_week == week)\n\n                    if exit_week is None or week <= exit_week:\n                        weekly_data.append({\n                            'celebrity': celebrity,\n                            'season': season,\n                            'week': week,\n                            'judge_score': avg_judge_score,\n                            'is_exited': is_exited,\n                            'exit_week': exit_week,\n                            'final_rank': final_rank,\n                            'placement': placement,\n                            'results': results\n                        })\n\n        self.processed_data = pd.DataFrame(weekly_data)\n        print(f"  处理完成: {len(self.processed_data)} 条周记录")\n\n        return self.processed_data\n\n    def calculate_actual_ranking(self):\n        """计算原排名（基于placement或final_rank）"""\n        print("\n[Step 3] 计算原排名...")\n\n        actual_rankings = []\n\n        for season in sorted(self.processed_data['season'].unique()):\n            season_data = self.processed_data[self.processed_data['season'] == season]\n\n            # 获取该赛季所有选手的最终排名\n            contestants = season_data.groupby('celebrity').agg({\n                'placement': 'first',\n                'final_rank': 'first'\n            }).reset_index()\n\n            # 使用placement或final_rank作为原排名\n            for _, row in contestants.iterrows():\n                rank = row['placement'] if pd.notna(row['placement']) else row['final_rank']\n                actual_rankings.append({\n                    'celebrity': row['celebrity'],\n                    'season': season,\n                    'actual_rank': rank\n                })\n\n        actual_rank_df = pd.DataFrame(actual_rankings)\n        print(f"  原排名计算完成: {len(actual_rank_df)} 位选手")\n\n        return actual_rank_df\n\n    def calculate_judge_ranking(self):\n        """计算导师评分排名（基于整季平均评委分）"""\n        print("\n[Step 4] 计算导师评分排名...")\n\n        judge_rankings = []\n\n        for season in sorted(self.processed_data['season'].unique()):\n            season_data = self.processed_data[self.processed_data['season'] == season]\n\n            # 计算每位选手的平均评委分\n            avg_scores = season_data.groupby('celebrity')['judge_score'].mean().reset_index()\n            avg_scores.columns = ['celebrity', 'avg_judge_score']\n\n            # 根据平均分排名（分数越高，排名越好，rank值越小）\n            avg_scores['judge_rank'] = rankdata(-avg_scores['avg_judge_score'], method='min')\n\n            for _, row in avg_scores.iterrows():\n                judge_rankings.append({\n                    'celebrity': row['celebrity'],\n                    'season': season,\n                    'judge_rank': row['judge_rank'],\n                    'avg_judge_score': row['avg_judge_score']\n                })\n\n        judge_rank_df = pd.DataFrame(judge_rankings)\n        print(f"  导师评分排名计算完成: {len(judge_rank_df)} 位选手")\n\n        return judge_rank_df\n\n    def simulate_alternative_scoring(self):\n        """\n        模拟另一评分方法并计算排名\n\n        评分方法：\n        - S1-2: 排名系统（Judge Rank + Fan Rank，越小越好）\n        - S3-27: 百分比系统（Judge% + Fan%，越大越好）\n        - S28+: 排名系统 + Judge Save\n        """\n        print("\n[Step 5] 模拟另一评分方法...")\n\n        alternative_rankings = []\n\n        for season in sorted(self.processed_data['season'].unique()):\n            print(f"  处理 Season {season}...")\n\n            season_data = self.processed_data[self.processed_data['season'] == season].copy()\n            season_fan_est = self.fan_estimation[self.fan_estimation['season'] == season].copy()\n\n            # 获取该赛季的所有周次\n            weeks = sorted(season_data['week'].unique())\n\n            # 记录每位选手的淘汰周次（模拟结果）\n            simulated_exit = {}\n            remaining_contestants = set(season_data['celebrity'].unique())\n\n            # 逐周模拟比赛\n            for week in weeks:\n                week_data = season_data[season_data['week'] == week].copy()\n                week_fan = season_fan_est[season_fan_est['week'] == week].copy()\n\n                # 只保留还在比赛中的选手\n                week_data = week_data[week_data['celebrity'].isin(remaining_contestants)]\n\n                if len(week_data) == 0:\n                    continue\n\n                # 合并评委分和粉丝投票预测\n                week_data = week_data.merge(\n                    week_fan[['celebrity', 'fan_percent_mean']],\n                    on='celebrity',\n                    how='left'\n                )\n\n                # 填充缺失的粉丝投票（如果有）\n                week_data['fan_percent_mean'].fillna(1.0 / len(week_data), inplace=True)\n\n                # 根据赛季确定评分系统\n                if 3 <= season < 28:\n                    # 百分比系统：归一化评委分和粉丝投票\n                    judge_total = week_data['judge_score'].sum()\n                    week_data['judge_percent'] = week_data['judge_score'] / judge_total\n\n                    # 粉丝投票已经是百分比\n                    week_data['fan_percent'] = week_data['fan_percent_mean']\n\n                    # 总分 = 评委% + 粉丝%（越大越好）\n                    week_data['total_score'] = week_data['judge_percent'] + week_data['fan_percent']\n\n                    # 排名（分数越高，排名越好）\n                    week_data['rank'] = rankdata(-week_data['total_score'], method='min')\n                else:\n                    # 排名系统：分别排名后相加\n                    week_data['judge_rank'] = rankdata(-week_data['judge_score'], method='min')\n                    week_data['fan_rank'] = rankdata(-week_data['fan_percent_mean'], method='min')\n\n                    # 总分 = 评委排名 + 粉丝排名（越小越好）\n                    week_data['total_score'] = week_data['judge_rank'] + week_data['fan_rank']\n\n                    # 排名（分数越小，排名越好）\n                    week_data['rank'] = rankdata(week_data['total_score'], method='min')\n\n                # 找出本周应该淘汰的选手（根据原始数据）\n                original_week = season_data[season_data['week'] == week]\n                exited_this_week = original_week[original_week['is_exited'] == True]['celebrity'].tolist()\n\n                # 记录淘汰信息\n                for celebrity in exited_this_week:\n                    if celebrity in remaining_contestants:\n                        simulated_exit[celebrity] = week\n                        remaining_contestants.remove(celebrity)\n\n            # 为所有选手分配最终排名\n            # 决赛选手（没有被淘汰的）根据最后一周的排名\n            finals_week = max(weeks)\n            finals_data = season_data[season_data['week'] == finals_week].copy()\n            finals_fan = season_fan_est[season_fan_est['week'] == finals_week].copy()\n\n            finals_data = finals_data.merge(\n                finals_fan[['celebrity', 'fan_percent_mean']],\n                on='celebrity',\n                how='left'\n            )\n            finals_data['fan_percent_mean'].fillna(1.0 / len(finals_data), inplace=True)\n\n            # 计算决赛排名\n            if 3 <= season < 28:\n                judge_total = finals_data['judge_score'].sum()\n                finals_data['judge_percent'] = finals_data['judge_score'] / judge_total\n                finals_data['total_score'] = finals_data['judge_percent'] + finals_data['fan_percent_mean']\n                finals_data['alternative_rank'] = rankdata(-finals_data['total_score'], method='min')\n            else:\n                finals_data['judge_rank'] = rankdata(-finals_data['judge_score'], method='min')\n                finals_data['fan_rank'] = rankdata(-finals_data['fan_percent_mean'], method='min')\n                finals_data['total_score'] = finals_data['judge_rank'] + finals_data['fan_rank']\n                finals_data['alternative_rank'] = rankdata(finals_data['total_score'], method='min')\n\n            # 记录所有选手的排名\n            all_contestants = season_data['celebrity'].unique()\n            for celebrity in all_contestants:\n                if celebrity in finals_data['celebrity'].values:\n                    rank = finals_data[finals_data['celebrity'] == celebrity]['alternative_rank'].iloc[0]\n                else:\n                    # 被淘汰的选手，排名根据淘汰顺序\n                    exit_week = simulated_exit.get(celebrity, None)\n                    if exit_week:\n                        # 同一周淘汰的选手排名相同\n                        same_week_exits = [c for c, w in simulated_exit.items() if w == exit_week]\n                        rank = len(all_contestants) - len(same_week_exits) + 1\n                    else:\n                        rank = None\n\n                alternative_rankings.append({\n                    'celebrity': celebrity,\n                    'season': season,\n                    'alternative_rank': rank\n                })\n\n        alternative_rank_df = pd.DataFrame(alternative_rankings)\n        print(f"  另一评分方法排名计算完成: {len(alternative_rank_df)} 位选手")\n\n        return alternative_rank_df\n\n    def calculate_spearman_correlations(self, ranking_table):\n        """\n        计算同季三个排名向量的两两斯皮尔曼相关系数\n\n        Args:\n            ranking_table: 包含三种排名的表格\n\n        Returns:\n            相关系数表格\n        """\n        print("\n[Step 6] 计算斯皮尔曼相关系数...")\n\n        correlation_records = []\n\n        for season in sorted(ranking_table['season'].unique()):\n            season_data = ranking_table[ranking_table['season'] == season].copy()\n\n            # 移除缺失值\n            season_data = season_data.dropna(subset=['actual_rank', 'judge_rank', 'alternative_rank'])\n\n            if len(season_data) < 3:\n                print(f"  Season {season}: 数据不足，跳过")\n                continue\n\n            # 计算三个排名向量\n            actual = season_data['actual_rank'].values\n            judge = season_data['judge_rank'].values\n            alternative = season_data['alternative_rank'].values\n\n            # 计算两两相关系数\n            corr_actual_judge, p_aj = spearmanr(actual, judge)\n            corr_actual_alt, p_aa = spearmanr(actual, alternative)\n            corr_judge_alt, p_ja = spearmanr(judge, alternative)\n\n            correlation_records.append({\n                'season': season,\n                'n_contestants': len(season_data),\n                'corr_actual_judge': corr_actual_judge,\n                'corr_actual_alternative': corr_actual_alt,\n                'corr_judge_alternative': corr_judge_alt,\n                'p_value_actual_judge': p_aj,\n                'p_value_actual_alternative': p_aa,\n                'p_value_judge_alternative': p_ja\n            })\n\n        correlation_df = pd.DataFrame(correlation_records)\n        print(f"  相关系数计算完成: {len(correlation_df)} 个赛季")\n\n        return correlation_df\n\n    def generate_ranking_table(self):\n        """生成排名总表：选手名 | 季数 | 原排名 | 导师评分排名 | 另一评分方法排名"""\n        print("\n[Step 7] 生成排名总表...")\n\n        # 计算三种排名\n        actual_rank_df = self.calculate_actual_ranking()\n        judge_rank_df = self.calculate_judge_ranking()\n        alternative_rank_df = self.simulate_alternative_scoring()\n\n        # 合并三种排名\n        ranking_table = actual_rank_df.merge(\n            judge_rank_df[['celebrity', 'season', 'judge_rank']],\n            on=['celebrity', 'season'],\n            how='outer'\n        )\n\n        ranking_table = ranking_table.merge(\n            alternative_rank_df[['celebrity', 'season', 'alternative_rank']],\n            on=['celebrity', 'season'],\n            how='outer'\n        )\n\n        # 重新排列列顺序\n        ranking_table = ranking_table[['celebrity', 'season', 'actual_rank', 'judge_rank', 'alternative_rank']]\n\n        # 排序\n        ranking_table = ranking_table.sort_values(['season', 'actual_rank'])\n\n        self.ranking_table = ranking_table\n        print(f"  排名总表生成完成: {len(ranking_table)} 位选手")\n\n        return ranking_table\n\n    def save_results(self, ranking_output='ranking_comparison_table.csv',\n                     correlation_output='spearman_correlation_table.csv'):\n        """保存结果到CSV文件"""\n        print("\n[Step 8] 保存结果...")\n\n        if self.ranking_table is None or self.correlation_table is None:\n            raise ValueError("请先运行 run_analysis() 生成结果")\n\n        # 保存排名总表\n        self.ranking_table.to_csv(ranking_output, index=False, encoding='utf-8-sig')\n        print(f"  排名总表已保存到: {ranking_output}")\n\n        # 保存相关系数表格\n        self.correlation_table.to_csv(correlation_output, index=False, encoding='utf-8-sig')\n        print(f"  相关系数表格已保存到: {correlation_output}")\n\n
    def visualize_results(self, output_file='advanced_evaluation_metrics_4panel.png'):
        """生成多维度结果评估可视化图表"""
        print("\n[Step 9] 生成可视化图表...")

        if self.ranking_table is None or self.correlation_table is None:
            raise ValueError("请先运行 run_analysis() 生成结果")

        # 数据分类：Era 1 & 3 are Rank-based, Era 2 is Percent-based.
        self.correlation_table['Method'] = self.correlation_table['season'].apply(
            lambda s: 'Rank Method' if (s <= 2 or s >= 28) else 'Percent Method'
        )
        self.ranking_table['Method'] = self.ranking_table['season'].apply(
            lambda s: 'Rank Method' if (s <= 2 or s >= 28) else 'Percent Method'
        )

        # 设置绘图风格
        sns.set_theme(style="white", palette="muted")
        fig, axes = plt.subplots(2, 2, figsize=(18, 14))
        fig.suptitle('Advanced Multi-Dimensional Evaluation of DWTS Voting Systems', fontsize=24, fontweight='bold', y=0.98)

        # --- Subplot A: Technical Bias Distribution (Violin Plot) ---
        sns.violinplot(data=self.correlation_table, x='Method', y='corr_actual_judge', inner="box", palette="Set2", ax=axes[0, 0])
        axes[0, 0].set_title('Subplot A: Technical Bias Distribution\n(Judge Score Influence)', fontsize=16, fontweight='bold')
        axes[0, 0].set_ylabel('Spearman Correlation (Rho)', fontsize=12)
        axes[0, 0].set_xlabel('Voting Scheme', fontsize=12)
        axes[0, 0].text(0.5, 0.45, 'Higher values indicate greater\nprotection of technical merit.', 
                       transform=axes[0, 0].transAxes, ha='center', fontsize=11, bbox=dict(facecolor='white', alpha=0.5))

        # --- Subplot B: Reversal Simulation (Famous Controversies) ---
        famous_stars = ["Jerry Rice", "Billy Ray Cyrus", "Bristol Palin", "Bobby Bones"]
        controversial_data = self.ranking_table[self.ranking_table['celebrity'].isin(famous_stars)].copy()
        
        # Melt for plotting
        melted_stars = controversial_data.melt(id_vars=['celebrity', 'season'], 
                                               value_vars=['actual_rank', 'alternative_rank', 'judge_rank'],
                                               var_name='Ranking_Type', value_name='Rank')

        sns.pointplot(data=melted_stars, x='Ranking_Type', y='Rank', hue='celebrity', 
                      markers=['o', 's', 'D', 'X'], linestyles=['-', '--', '-.', ':'], ax=axes[0, 1])
        axes[0, 1].invert_yaxis()
        axes[0, 1].set_title('Subplot B: Reversal Simulation\n(Famous Controversial Trajectories)', fontsize=16, fontweight='bold')
        axes[0, 1].set_xticklabels(['Actual Rank', 'Simulated Alt', 'Judge-Only'])
        axes[0, 1].set_ylabel('Placement Rank', fontsize=12)
        axes[0, 1].legend(title='Contestant', loc='lower right', frameon=True)

        # --- Subplot C: System Stability Assessment (KDE Plot) ---
        self.ranking_table['Delta_R'] = abs(self.ranking_table['actual_rank'] - self.ranking_table['alternative_rank'])
        sns.kdeplot(data=self.ranking_table, x='Delta_R', hue='Method', fill=True, common_norm=False, palette="husl", alpha=.5, linewidth=2, ax=axes[1, 0])
        axes[1, 0].set_title('Subplot C: System Stability Assessment\n(Distribution of Rank Deviation ΔR)', fontsize=16, fontweight='bold')
        axes[1, 0].set_xlabel('Rank Displacement (|Actual - Alternative|)', fontsize=12)
        axes[1, 0].set_ylabel('Density', fontsize=12)
        axes[1, 0].text(0.6, 0.7, 'Fatter tails represent\nhigher system volatility.', 
                       transform=axes[1, 0].transAxes, ha='center', fontsize=11, color='darkred')

        # --- Subplot D: Outcome Predictability (Volatility Plot) ---
        stability_metrics = self.correlation_table.groupby('Method')['corr_actual_judge'].std().reset_index()
        stability_metrics.columns = ['Method', 'Rho_Std_Dev']
        sns.barplot(data=stability_metrics, x='Method', y='Rho_Std_Dev', palette="viridis", ax=axes[1, 1])
        axes[1, 1].set_title('Subplot D: Outcome Predictability\n(Volatility of Technical Correlation)', fontsize=16, fontweight='bold')
        axes[1, 1].set_ylabel('Std Dev of Correlation (σ)', fontsize=12)
        axes[1, 1].set_xlabel('Voting Scheme', fontsize=12)
        
        for p in axes[1, 1].patches:
            axes[1, 1].annotate(f'{p.get_height():.3f}', (p.get_x() + p.get_width() / 2., p.get_height()),
                                ha='center', va='center', xytext=(0, 9), textcoords='offset points', fontsize=12, fontweight='bold')

        plt.tight_layout(rect=[0, 0.03, 1, 0.95])
        plt.savefig(output_file, dpi=300)
        print(f"  可视化图表已保存到: {output_file}")

    def generate_summary_metrics(self, output_file='summary_metrics_table.csv'):
        """生成各维度评估指标汇总表"""
        print("\n[Step 10] 生成评估指标汇总表...")
        
        if self.correlation_table is None:
            raise ValueError("请先运行 run_analysis() 生成结果")

        summary_table = self.correlation_table.groupby('Method').agg({
            'corr_actual_judge': ['mean', 'std'],
            'corr_actual_alternative': 'mean'
        }).round(4)
        summary_table.columns = ['Technical_Bias_Mean', 'Technical_Bias_Std', 'Method_Consistency_Mean']
        
        summary_table.to_csv(output_file, encoding='utf-8-sig')
        print(f"  评估指标汇总表已保存到: {output_file}")
\n    def display_summary(self):\n        """显示分析结果摘要"""\n        print("\n" + "=" * 60)\n        print("分析结果摘要")\n        print("=" * 60)\n\n        if self.ranking_table is None or self.correlation_table is None:\n            print("请先运行 run_analysis() 生成结果")\n            return\n\n        # 排名表摘要\n        print("\n【排名总表摘要】")\n        print(f"总选手数: {len(self.ranking_table)}")\n        print(f"总赛季数: {self.ranking_table['season'].nunique()}")\n        print(f"\n前10行数据:")\n        print(self.ranking_table.head(10).to_string())\n\n        # 相关系数摘要\n        print("\n【斯皮尔曼相关系数摘要】")\n        print(f"分析赛季数: {len(self.correlation_table)}")\n        print(f"\n平均相关系数:")\n        print(f"  原排名 vs 导师评分排名: {self.correlation_table['corr_actual_judge'].mean():.4f}")\n        print(f"  原排名 vs 另一评分方法: {self.correlation_table['corr_actual_alternative'].mean():.4f}")\n        print(f"  导师评分 vs 另一评分方法: {self.correlation_table['corr_judge_alternative'].mean():.4f}")\n        print(f"\n相关系数表格:")\n        print(self.correlation_table.to_string())\n\n    def run_analysis(self):\n        """运行完整的分析流程"""\n        print("\n" + "=" * 60)\n        print("开始运行完整分析流程")\n        print("=" * 60)\n\n        # Step 1-2: 加载和预处理数据\n        self.load_data()\n        self.preprocess_data()\n\n        # Step 3-7: 生成排名总表\n        self.generate_ranking_table()\n\n        # Step 6: 计算相关系数\n        self.correlation_table = self.calculate_spearman_correlations(self.ranking_table)\n\n        # Step 8: 保存结果\n        self.save_results()\n\n        # 显示摘要\n        # Step 9-10: 生成可视化和汇总指标\n        self.visualize_results()\n        self.generate_summary_metrics()\n        self.display_summary()\n\n        print("\n" + "=" * 60)\n        print("分析完成！")\n        print("=" * 60)\n\n\ndef main():\n    """主函数"""\n    print("\n" + "=" * 60)\n    print("问题2：评分方法对比与排名分析")\n    print("=" * 60)\n\n    # 初始化分析器\n    analyzer = RankingComparisonAnalyzer(\n        original_data_path='2026_MCM_Problem_C_Data.csv',\n        competition_info_path='competition_info_table.csv',\n        fan_estimation_path='fan_percent_estimation_results.csv'\n    )\n\n    # 运行完整分析\n    analyzer.run_analysis()\n\n\nif __name__ == '__main__':\n    main()\n\n\n\n\n\n